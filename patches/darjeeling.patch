diff --git a/src/darjeeling/cli/__init__.py b/src/darjeeling/cli/__init__.py
index 38a7cd1..f5cda0c 100644
--- a/src/darjeeling/cli/__init__.py
+++ b/src/darjeeling/cli/__init__.py
@@ -88,7 +88,7 @@ class BaseController(cement.Controller):
     def _default_log_filename(self) -> str:
         # find all log file numbers that have been used in this directory
         used_numbers = [int(s.rpartition('.')[-1])
-                        for s in glob.glob('darjeeling.log.*')]
+                        for s in glob.glob('darjeeling.log.[0-9]*')]
 
         if not used_numbers:
             return os.path.join(os.getcwd(), 'darjeeling.log.0')
@@ -229,6 +229,7 @@ class BaseController(cement.Controller):
                 stdout_logging_level = 'TRACE'
             else:
                 stdout_logging_level = 'INFO'
+            logger.enable('kaskara')
             logger.add(sys.stdout, level=stdout_logging_level)
 
         # setup logging to file
diff --git a/src/darjeeling/coverage/gcov.py b/src/darjeeling/coverage/gcov.py
index 01b21c8..a5c2f79 100644
--- a/src/darjeeling/coverage/gcov.py
+++ b/src/darjeeling/coverage/gcov.py
@@ -1,9 +1,8 @@
 # -*- coding: utf-8 -*-
 __all__ = ('GCovCollector',)
 
-from typing import FrozenSet, Mapping, Any, Set, Dict, Optional, ClassVar
 import os
-import typing
+import typing as t
 import xml.etree.ElementTree as ET
 
 from loguru import logger
@@ -11,8 +10,9 @@ import attr
 
 from .collector import CoverageCollector, CoverageCollectorConfig
 from ..core import FileLineSet
+from ..source import ProgramSourceFile
 
-if typing.TYPE_CHECKING:
+if t.TYPE_CHECKING:
     from ..container import ProgramContainer
     from ..environment import Environment
     from ..program import ProgramDescription
@@ -32,8 +32,8 @@ _INSTRUMENTATION = (
     "  if(sig != SIGUSR1 && sig != SIGUSR2)\n"
     "    exit(1);\n"
     "}\n"
-    "void darjeeling_ctor (void) __attribute__ ((constructor));\n"
-    "void darjeeling_ctor (void) {\n"
+    "void __attribute__ ((constructor)) darjeeling_ctor (void) {\n"
+    #"void darjeeling_ctor (void) {\n"
     "  struct sigaction new_action;\n"
     "  new_action.sa_handler = darjeeling_sighandler;\n"
     "  sigemptyset(&new_action.sa_mask);\n"
@@ -56,23 +56,64 @@ _NUM_INSTRUMENTATION_LINES = _INSTRUMENTATION.count('\n')
 _LINES_TO_REMOVE = set(range(1, _NUM_INSTRUMENTATION_LINES))
 
 
+@attr.s(auto_attribs=True, slots=True)
+class FileToInstrument:
+    filename: str
+    line: int = attr.ib(default=0)
+
+    @classmethod
+    def from_dict(
+        cls,
+        dict_or_filename: t.Union[str, t.Dict[str, t.Any]],
+    ) -> "FileToInstrument":
+        if isinstance(dict_or_filename, str):
+            filename = dict_or_filename
+            line = 0
+        else:
+            filename = dict_or_filename["filename"]
+            line = dict_or_filename["line"]
+        return FileToInstrument(
+            filename=filename,
+            line=line,
+        )
+
+    def resolve(self, source_directory: str) -> "FileToInstrument":
+        if os.path.isabs(self.filename):
+            return self
+        return FileToInstrument(
+            filename=os.path.join(source_directory, self.filename),
+            line=self.line,
+        )
+
+
 @attr.s(frozen=True, slots=True, auto_attribs=True)
 class GCovCollectorConfig(CoverageCollectorConfig):
-    NAME: ClassVar[str] = 'gcov'
-    files_to_instrument: FrozenSet[str]
+    NAME: t.ClassVar[str] = 'gcov'
+    files_to_instrument: t.Collection[FileToInstrument]
 
     @classmethod
-    def from_dict(self,
-                  dict_: Mapping[str, Any],
-                  dir_: Optional[str] = None
-                  ) -> 'CoverageCollectorConfig':
+    def from_dict(
+        cls,
+        dict_: t.Mapping[str, t.Any],
+        dir_: t.Optional[str] = None
+    ) -> 'CoverageCollectorConfig':
         assert dict_['type'] == 'gcov'
-        files_to_instrument = frozenset(dict_.get('files-to-instrument', []))
-        return GCovCollectorConfig(files_to_instrument=files_to_instrument)
+
+        # files to instrument
+        files_to_instrument: t.Collection[FileToInstrument] = frozenset()
+        if "files-to-instrument" in dict_:
+            files_to_instrument = [
+                FileToInstrument.from_dict(dd)
+                for dd in dict_['files-to-instrument']
+            ]
+
+        config = GCovCollectorConfig(files_to_instrument=files_to_instrument)
+        logger.trace(f"gcov config: {config}")
+        return config
 
     def _find_source_filenames(self,
                                program: 'ProgramDescription'
-                               ) -> FrozenSet[str]:
+                               ) -> t.FrozenSet[str]:
         """Determines the set of all source files within a program."""
         with program.provision() as container:
             source_directory = program.source_directory
@@ -82,21 +123,23 @@ class GCovCollectorConfig(CoverageCollectorConfig):
             output = container.shell.check_output(command, text=True)
             return frozenset(filename.strip() for filename in output.split('\n'))
 
-    def build(self,
-              environment: 'Environment',
-              program: 'ProgramDescription'
-              ) -> 'CoverageCollector':
+    def build(
+        self,
+        environment: 'Environment',
+        program: 'ProgramDescription',
+    ) -> 'CoverageCollector':
         source_directory = program.source_directory
         source_filenames = self._find_source_filenames(program)
-        files_to_instrument = frozenset(
-            fn if os.path.isabs(fn) else os.path.join(source_directory, fn)
-            for fn in self.files_to_instrument)
-
-        collector = GCovCollector(environment=environment,
-                                  program=program,
-                                  source_directory=source_directory,
-                                  source_filenames=source_filenames,
-                                  files_to_instrument=files_to_instrument)
+        files_to_instrument = [
+            f.resolve(source_directory) for f in self.files_to_instrument
+        ]
+        collector = GCovCollector(
+            environment=environment,
+            program=program,
+            source_directory=source_directory,
+            source_filenames=source_filenames,
+            files_to_instrument=files_to_instrument,
+        )
         logger.trace(f"built coverage collector: {collector}")
         return collector
 
@@ -105,11 +148,11 @@ class GCovCollectorConfig(CoverageCollectorConfig):
 class GCovCollector(CoverageCollector):
     program: 'ProgramDescription'
     _source_directory: str
-    _files_to_instrument: FrozenSet[str]
-    _source_filenames: FrozenSet[str]
+    _files_to_instrument: t.Collection[FileToInstrument]
+    _source_filenames: t.FrozenSet[str]
     _environment: 'Environment' = attr.ib(repr=False)
 
-    def _read_line_coverage_for_class(self, xml_class: ET.Element) -> Set[int]:
+    def _read_line_coverage_for_class(self, xml_class: ET.Element) -> t.Set[int]:
         xml_lines = xml_class.find('lines')
         assert xml_lines
         lines = xml_lines.findall('line')
@@ -118,14 +161,15 @@ class GCovCollector(CoverageCollector):
 
     def _corrected_lines(self,
                          relative_filename: str,
-                         lines: Set[int]
-                         ) -> Set[int]:
+                         lines: t.Set[int]
+                         ) -> t.Set[int]:
         if os.path.isabs(relative_filename):
             absolute_filename = relative_filename
         else:
             absolute_filename = os.path.join(self._source_directory, relative_filename)
 
-        if absolute_filename not in self._files_to_instrument:
+        instrumented_filenames = set(f.filename for f in self._files_to_instrument)
+        if absolute_filename not in instrumented_filenames:
             logger.trace(f"file was not instrumented: {absolute_filename}")
             return lines
 
@@ -137,7 +181,7 @@ class GCovCollector(CoverageCollector):
         filename_absolute = os.path.join(source_directory, filename_relative)
         return filename_absolute in self._source_filenames
 
-    # FIXME is this a general solution?
+    # FIXME is this a general solution? nope, not a general solution
     def _resolve_filepath(self, filename_relative: str) -> str:
         if not filename_relative:
             raise ValueError('failed to resolve path')
@@ -147,18 +191,22 @@ class GCovCollector(CoverageCollector):
         filename_relative_child = '/'.join(filename_relative.split('/')[1:])
         return self._resolve_filepath(filename_relative_child)
 
+    def _resolve_filepath_pdr(self, base_filename: str) -> str:
+        similar=[x for x in self._source_filenames if x.endswith(base_filename)]
+        return similar[-1].lstrip(self._source_directory)
+
     def _parse_xml_report(self, root: ET.Element) -> FileLineSet:
         packages_node = root.find('packages')
         assert packages_node
         package_nodes = packages_node.findall('package')
         class_nodes = [c for p in package_nodes for c in p.find('classes').findall('class')]  # type: ignore
 
-        filename_to_lines: Dict[str, Set[int]] = {}
+        filename_to_lines: t.Dict[str, t.Set[int]] = {}
         for node in class_nodes:
             filename = node.attrib['filename']
             try:
                 filename_original = filename
-                filename = self._resolve_filepath(filename)
+                filename = self._resolve_filepath_pdr(filename)
                 logger.trace(f"resolving path '{filename_original}' "
                              f"-> '{filename}'")
             except ValueError:
@@ -189,6 +237,18 @@ class GCovCollector(CoverageCollector):
 
         return self._parse_xml_file_contents(xml_file_contents)
 
+    def _instrument(
+        self,
+        filename: str,
+        contents: str,
+        inject_at_line: int,
+    ) -> str:
+        file_ = ProgramSourceFile(filename, contents)
+        inject_at_location = file_.line_to_location_range(inject_at_line).start
+        inject_at_offset = file_.location_to_offset(inject_at_location)
+        contents = contents[0:inject_at_offset] + _INSTRUMENTATION + contents[inject_at_offset:]
+        return contents
+
     def _prepare(self, container: 'ProgramContainer') -> None:
         """
         Adds source code instrumentation and recompiles the program inside
@@ -196,11 +256,18 @@ class GCovCollector(CoverageCollector):
         gcovr is installed inside the container.
         """
         files = container.filesystem
-        for filename in self._files_to_instrument:
+        for file_to_instrument in self._files_to_instrument:
+            filename = file_to_instrument.filename
             logger.trace(f'adding gcov instrumentation to {filename}')
             contents_original = files.read(filename)
             logger.trace(f'original file [{filename}]:\n{contents_original}')
-            contents_instrumented = _INSTRUMENTATION + contents_original
+            # FIXME add instrumentation at before specified line
+            # contents_instrumented = _INSTRUMENTATION + contents_original
+            contents_instrumented = self._instrument(
+                filename=filename,
+                contents=contents_original,
+                inject_at_line=file_to_instrument.line,
+            )
             logger.trace(f'instrumented file [{filename}]:\n{contents_instrumented}')
             files.write(filename, contents_instrumented)
 
diff --git a/src/darjeeling/localization.py b/src/darjeeling/localization.py
index 5823b6c..bec124a 100644
--- a/src/darjeeling/localization.py
+++ b/src/darjeeling/localization.py
@@ -142,6 +142,7 @@ class Localization:
             m = f"suspiciousness metric not supported: {cfg.metric}"
             raise BadConfigurationException(m)
         logger.info(f"using suspiciousness metric: {cfg.metric}")
+        logger.info(f"coverage: {str(coverage)}")
 
         loc = Localization.from_coverage(coverage, metric)
         loc = loc.exclude_files(cfg.exclude_files)
