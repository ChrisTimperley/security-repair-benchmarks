"""
This script assesses the quality of patchs generated by darjeeling and darjeeling++
in terms of fault localization. This quality script compares the location of the
tool-created patch to the human fix for the given defect.

To use this script, you will need three arguments:
1. bug_json_path: the path to the bug.json for the vulnerability (this file contains 
        information about the developer fix)
2. tool_run_path: the path to the standard output of a tool run (not the log file). 
        The tool is either Darjeeling or Darjeeling++
3. patch_folder: the path to a folder which contains patches produced by the tool above
        for which you would like to know the quality

It is run: python3 test_patch_quality.py bug_json_path tool_run_path patch_folder

This script evaluates the following metrics of patch fault localization quality:
FIXME - make this documentation clear
"""

import json

def read_patch(patch_file_path):
    # This function finds the lines implicated in a patch
    #FIXME: handle multiple changed patch locations if needed
    with open(patch_file_path, 'r') as patch_file:
        patch = patch_file.read().splitlines()
    files_implicated = set()
    file_implicated = None
    start_line_num = None
    num_lines_implicated = None
    lines_added = []
    lines_deleted = []
    for line in patch:
        if line.startswith('+++'):
            file_implicated = line.strip().split()[1]
            files_implicated.add(file_implicated)
        if line.startswith('@@'):
            # In this case, this will give us the location information
            location_notes = line.strip().split()[1].split(',')
            start_line_num = int(location_notes[0]) + 3
            num_lines_implicated = int(location_notes[1]) - 6

    if len(files_implicated) > 1:
        raise ValueError("There should only be one file modified by the tool")
    elif len(file_implicated) == 0:
        raise ValueError("At least one file must have been modified by the tool for a patch")
    elif file_implicated is None or start_line_num is None or num_lines_implicated is None:
        raise RuntimeError("Could not parse patch diff")
    
    split_path = patch_file_path.split('/')
    return {
        "file": file_implicated,
        "start_line": start_line_num,
        "num_lines": num_lines_implicated,
        "name": split_path[-2] + '/' + split_path[-1]
    }

def read_bug_json(bug_json_file_path):
    """
    returns a list of dictionaries of the form:
    [{  "file": "tools/tiffcrop.c",
        "functions": [{ "name": "readContigStripsIntoBuffer", 
                        "start_line": 3673, 
                        "end_line": 3705,
                        "lines_modified": [3701]
                     }]
    }] 
    """
    with open(bug_json_file_path, 'r') as bug_json_file:
        bug_json = json.load(bug_json_file)
    return bug_json["developer_fix"], bug_json["subject"], bug_json["name"]


def read_tool_output(tool_output_file_path):
    """
    This function pulls the important information out of the tool output file. Currently this is what is
    printed to standard out, but could be changed to be what is in the log file. It will work as long as
    the file contains the following things:

    1. Deliminator bookended list of files and lines implicated in the fault localization. This should
        only contain lines that are implicated for all files. There should be no ) after the opening ( until
        the localization list is done. Each line in this list should be unique.
            Localization(
            tools/tiffcrop.c:2049: ...
            tools/tiffcrop.c:3043: ..
            ...
            tools/somefile.c:2934: ...)
    2. The last four lines in the file are of the same form as the end of the default darjeeling output:
            2022-03-07 14:57:10.220 | INFO     | darjeeling.session:close:201 - found 2 plausible patches
            2022-03-07 14:57:10.220 | INFO     | darjeeling.session:close:202 - time taken: 3.97 minutes
            2022-03-07 14:57:10.220 | INFO     | darjeeling.session:close:203 - # test evaluations: 100
            2022-03-07 14:57:10.220 | INFO     | darjeeling.session:close:204 - # candidate evaluations: 100
    """
    with open(tool_output_file_path, 'r') as tool_output_file_path:
        tool_output = tool_output_file_path.read().splitlines()
    
    # read in the localization information
    files_implicated = set()
    num_lines_implicated = 0
    inLoc = False
    for line in tool_output:
        line = line.strip()
        if line.startswith('Localization('): inLoc = True
        elif inLoc: 
            line = line.split(':')
            files_implicated.add(line[0])
            num_lines_implicated += 1

            if line[-1].find(')') != -1: break # If we have finished the list

    # Get the time taken
    time_taken = float(tool_output[-3].split()[-2].strip())

    # Get the number of plausible patches found
    plausible_patches_found = int(tool_output[-4].split()[-3].strip())
    
    # Get the number of candidate evaluations:
    num_candidate_evals = int(tool_output[-1].split()[-1].strip())

    # Return a dictionary with all of the important information
    return {"time": time_taken, 
            "num_patches": plausible_patches_found, 
            "time_per_patch": time_taken / plausible_patches_found,
            "num_candidates": num_candidate_evals,
            "num_files_implicated": len(files_implicated),
            "num_lines_implicated": num_lines_implicated
            }

def print_run_metrics(tool_output, project, cve):
    print("Assessing fault localization quality for patches generated for {} in project {}:".format(cve, project))
    print("\tTool evaluated {} candidate patches and found {} plausible repairs in {} minutes".format(tool_output["num_candidates"], 
                                                                                                            tool_output["num_patches"], 
                                                                                                            tool_output["time"]))
    print()
    print('Overall run metrics:')
    print('\tAverage time to find one patch (lower is better): {} minutes'.format(tool_output["time_per_patch"]))
    print('\tNumber of files implicated during fault localization (lower is better): {} files'.format(tool_output['num_files_implicated']))
    print('\tNumber of lines implicated during fault localization (lower is better): {} lines'.format(tool_output['num_lines_implicated']))
    print()

def print_patch_specific_metrics(this_patch, dev_fix):
    print("Quality of patch " + patch["name"] + ':')

    # first, count up the number of things modified in the developer fix
    num_dev_files_modified = len(dev_fix)
    num_dev_functions_modified = sum(len(f["functions"]) for f in dev_fix)
    num_dev_lines_modified = sum(sum(len(function["lines_modified"]) for function in f["functions"]) for f in dev_fix)
    
    # Now, determine if the produced patch was in a file modified by the developer
    in_correct_file = this_patch["file"] in {f['file'] for f in dev_fix} #FIXME debug / double check
    print("\tPatch is in correct file (True is better): ", in_correct_file)
    
    in_correct_function = False
    
    if in_correct_file:
        # Find the index of the correct file
        for f in dev_fix:
            if f["file"] == this_patch["file"]:
                correct_file = f
                break
        
        for function in correct_file["functions"]:
            if this_patch["start_line"] >= function["start_line"] and this_patch["start_line"] <= function["endline"]:
                in_correct_function = True
                dev_function_lines_modified = function["lines_modified"]
                break
    
    print("\tPatch is in correct function (True is better): ", in_correct_function)

    in_correct_line = False

    if in_correct_function:
        for line in dev_function_lines_modified:
            if line > this_patch["start_line"] and line < (this_patch["start_line"] + this_patch["num_lines"]):
                in_correct_line = True
                break
    print("\tPatch modifies a line the developer modified (True is better):", in_correct_line)
    
    print("\tNumber of source code lines modified by patch (lower is better):", this_patch["num_lines"], "lines (developer patch modified", num_dev_lines_modified, "lines)")
    print()




if __name__ == "__main__":
    #
    #baseline_path = sys.argv[3]
    #plus_path = sys.argv[4]

    import sys
    import os

    #python3 test_patch_quality.py bug_json_path tool_run_path patch_folder
    bug_json_path = sys.argv[1]
    print(bug_json_path)
    tool_output_path = sys.argv[2]
    patch_folder = sys.argv[3]

    # Get necessary information from the two files
    dev_fix, project_name, cve_number = read_bug_json(bug_json_path)
    tool_output = read_tool_output(tool_output_path)

    # Print the summary information
    print_run_metrics(tool_output, project_name, cve_number)

    # Print the detailed information for each plausible patch

    for filename in os.listdir(patch_folder):
        patch_file = os.path.join(patch_folder, filename)
        # checking if it is a file
        if os.path.isfile(patch_file):
            patch = read_patch(patch_file)
            print_patch_specific_metrics(patch, dev_fix)



