#! /usr/bin/env python3
import os.path
import json
from collections import defaultdict

"""
This file contains functions that parse a addressSanitizer or undefinedSanitizer message and put the results into json form.

To run call: parse_sanitizer_message(str-of-program-output-when-run-with-sanitizers): 
Note - this must contain newlines as the output is typically produced

This function returns a string which can be turned into json running json.loads(str)

json fields:

num_ubsan: number of undefined behavior sanitizer findings from running the program with -fsanitize ubsan
ubsans: a list with a dictionary of details for each undefined behavior sanitizer finding if num_ubsan > 0. Each list entry contains:
    type: descriptive text generated by the sanitizer (e.g. "division by zero")
    loc: ["file name", "file path", line number, character number, "function name"] for the primary location reported.
        Note: for ubsan, "file path" and "function name" are generally empty (null)
num_addsan: number of address sanitizer findings from running the program with address sanitizer enabled
addsans: a list with a dictionary of details for each address sanitizer finding if num_addsan > 0. Each list entry contains: 
    type: descriptive test generated by the sanitizer (e.g., "FPE" or "heap-buffer-overflow")
    loc: ["file name", "file path", line number, character number, "function name"] for the primary location reported.
        Note: this one usually has all the values filled, but if the "trace" list is empty, it will not contain the "file path" or "function_value"
            Usually the last address sanitizer result in the list is the most important one
    trace: a list of locations from the address sanitizer stack trace. It goes from the closest location to the main function. 
        Each location contains ["file name", "file path", line number, character number, "function name"]
    

Example json entry:
{
    "num_ubsan": 1,
    "ubsans": [
        {
            "type": "division by zero",
            "loc": ["tif_ojpeg.c", [list_of_possible_path_locations], 816, 8, null]
        }
    ],
    "num_addsan": 2,
    "addsans": [
        {
            "type": "undefined-behavior",
            "loc": ["tif_ojpeg.c", null, 816, 8, null],
            "trace": []
        },
        {
            "type": "FPE",
            "loc": ["tif_ojpeg.c", "/benchmarks/libtiff/bugzilla_2611/source/libtiff", 816, 8, "OJPEGDecodeRaw"],
            "trace": [
                ["tif_ojpeg.c", "/benchmarks/libtiff/bugzilla_2611/source/libtiff", 816, 8, "OJPEGDecodeRaw"],
                ["tif_ojpeg.c", "/benchmarks/libtiff/bugzilla_2611/source/libtiff", 791, 7, "OJPEGDecode"],
                ["tif_read.c", "/benchmarks/libtiff/bugzilla_2611/source/libtiff", 304, 7, "TIFFReadScanline"],
                ["tiffmedian.c", "/benchmarks/libtiff/bugzilla_2611/source/tools", 771, 7, "quant"],
                ["tiffmedian.c", "/benchmarks/libtiff/bugzilla_2611/source/tools", 283, 3, "main"]
            ]
        }
    ]
}
"""

def parse_undefined_sanitizer(str_message, json_message):
    """
    This function adds info for each undefined sanitizer result (expressed as a runtime error)
    """
    # first, split the message into lines that contain " runtime error: "
    type_loc = " runtime error: "
    ubsan_lines = [m for m in str_message.splitlines() if m.find(type_loc) != -1]
    
    # Add the number of ubsan to the json
    json_message["num_ubsan"] = len(ubsan_lines)
    json_message["ubsans"] = []
    
    # Go through each ubsan, and add the details
    for line in ubsan_lines:
        ubsan_to_add = {"type": line[line.find(type_loc) + len(type_loc):]}
        first_col = line.find(':') + 1
        second_col = line[first_col:].find(':') + first_col + 1
        third_col = line[second_col:].find(':') + second_col + 1
        ubsan_to_add["loc"] = [line[:first_col - 1], None, int(line[first_col:second_col - 1]), int(line[second_col:third_col - 1]), None]
        json_message["ubsans"].append(ubsan_to_add)

    return json_message

def parse_simple_address_sanitizer(sanitizer_line, json_message):
    """
    This function adds address sanitizers that would be attached to an undefined sanitizer if the program was also run with that
    """
    json_message["num_addsan"] += 1
    addsan_to_add = {"type": "undefined-behavior", "trace": []}
    file_start = sanitizer_line.find("undefined-behavior ") + len("undefined-behavior ")
    line = sanitizer_line[file_start:]
    first_col = line.find(':') + 1
    second_col = line[first_col:].find(':') + first_col + 1
    third_col = line[second_col:].find(' ') + second_col + 1
    addsan_to_add["loc"] = [line[:first_col - 1], None, int(line[first_col:second_col - 1]), int(line[second_col:third_col - 1]), None]
    json_message["addsans"].append(addsan_to_add)
    return json_message

def parse_complex_address_sanitizer(sanitizer_lines, json_message):
    """
    This function adds the address sanitizer that is not attached to an undefined sanitizer if the program was also run with that
    """
    json_message["num_addsan"] += 1

    # First get the error type
    addsan_to_add = {"trace": [], "loc": [None, None, None, None, None]} 

    loc_flag = "==ERROR: AddressSanitizer: "

    if sanitizer_lines[0].find(loc_flag) != -1:
        error_line = sanitizer_lines[0][sanitizer_lines[0].find(loc_flag) + len(loc_flag):]
        addsan_to_add["type"] = (error_line[:error_line.find(':')] if error_line.find(':') != -1 else error_line[:error_line.find(' ')])
    else: # When it is a leak sanitizer instead
        loc_flag = "==ERROR: LeakSanitizer: "
        error_line = sanitizer_lines[0][sanitizer_lines[0].find(loc_flag) + len(loc_flag):]
        addsan_to_add["type"] = (error_line[:error_line.find(':')] if error_line.find(':') != -1 else error_line)

    # Now fill in the trace
    in_trace = False
    for i in range(len(sanitizer_lines)):
        line = sanitizer_lines[i].strip()
        #print(line, line.startswith('#'), in_trace)
        if line.startswith('#'): # enter the trace
            in_trace = True
        if in_trace and not line.startswith('#'): break # we have finished the trace

        if not in_trace or line.rfind(':') == -1 or line.find("??:0:0") != -1: continue # if not in the trace or not a resolved path

        func_name = line[line.find('in') + 3: line.find('/') - 1]
        path = os.path.split(line[line.find('/'): line.find(':')])
        line_num = int(line[line.find(':') + 1: line.rfind(':')])
        char_offset = int(line[line.rfind(':') + 1:])
        addsan_to_add["trace"].append([path[1], path[0], line_num, char_offset, func_name])
        
    #Finally, copy the first trace into the loc
    addsan_to_add["loc"] = addsan_to_add["trace"][0]

    json_message["addsans"].append(addsan_to_add)
    return json_message

def parse_address_sanitizer(str_message, json_message):
    """
    This function adds info for each address sanitizer result (expressed as a runtime error)
    """
    str_message_lines = str_message.splitlines()
    json_message["addsans"] = []
    for i in range(len(str_message_lines)):

        # If we see this start, we have gotten to the last complex message
        if str_message_lines[i].find("==ERROR: ") != -1: 
            return parse_complex_address_sanitizer(str_message_lines[i:], json_message)

        # Otherwise, it is a simple one
        if str_message_lines[i].find(" AddressSanitizer: ") != -1:
            json_message = parse_simple_address_sanitizer(str_message_lines[i], json_message)

    return json_message

def collect_compile_paths(file_path):
    with open(file_path, 'r') as compile_commands_file:
        compile_commands_json = json.load(compile_commands_file)
        files_to_check = defaultdict(set)
        for command in compile_commands_json:
            path = os.path.split(command["file"])
            files_to_check[path[1]].add(path[0])
    
    return files_to_check



def parse_sanitizer_message(str_message, resolve_paths=False):
    """
    returns a dumped json string of the message str_message, paths_file is the path
    to a file that contains the compile_commands.json used for path expansion
    """
    json_message = {"num_ubsan": 0, "num_addsan": 0}
    if str_message.find(" runtime error: ") != -1:
        json_message = parse_undefined_sanitizer(str_message, json_message)
    
    if str_message.find(" AddressSanitizer: ") != -1:
        json_message = parse_address_sanitizer(str_message, json_message)
    
    if resolve_paths and json_message["num_ubsan"] > 0: 

        possible_paths = collect_compile_paths('/workspace/compile_commands.json')

        # If we want to try and expand paths and there are paths to expand
        for i in range(json_message["num_ubsan"]):
            ubsan = json_message["ubsans"][i]

            # Get the actual file name:
            old_path = ubsan['loc'][0]
            if old_path.find('/') != -1: old_path = old_path[old_path.rfind('/') + 1:]

            ubsan['loc'][0] = old_path
            ubsan['loc'][1] = list(possible_paths[old_path])

    return json.dumps(json_message, indent=4)

def main():
    #open file with sanitizer output
    of = open("bothSan.output", 'r')
    lns = of.read()
    of.close()
    #call parse_sanitizer_message
    of = open("bothSan.json", 'w')
    try:
        of.write(parse_sanitizer_message(lns, True))
    except: 
        pass
    of.close()

if __name__ == "__main__":
    
    main()
    """
    import example_sanitzer_outputs as eso


    def check_test(generated_json_str, test_json_str):
        generated_json = json.loads(generated_json_str)
        test_json = json.loads(test_json_str)
        print(generated_json, test_json)
        return sorted(generated_json.items()) == sorted(test_json.items())

    implemented_tests = [
        [1, eso.test_1, eso.test_1_json],
        [2, eso.test_2, eso.test_2_json],
        [3, eso.test_3, eso.test_3_json],
        [4, eso.test_4, eso.test_4_json],
        [6, eso.test_6, eso.test_6_json],
        [7, eso.test_7, eso.test_7_json],
        [9, eso.test_9, eso.test_9_json],
        [17, eso.test_17, eso.test_17_json]
    ]

    print("All of these should be true:")
    [print("Test " + str(a[0]) + ": " + str(check_test(parse_sanitizer_message(a[1]), a[2]))) for a in implemented_tests]
    """
    
